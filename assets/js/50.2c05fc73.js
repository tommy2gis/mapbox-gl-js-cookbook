(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{205:function(t,e,n){var i=n(11).f,o=Function.prototype,r=/^\s*function ([^ (]*)/;"name"in o||n(1)&&i(o,"name",{configurable:!0,get:function(){try{return(""+this).match(r)[1]}catch(t){return""}}})},246:function(t,e,n){"use strict";var i=n(57),o=n(58),r=n(64),s=n(63),a=n(86),c=n(65),l=n(330),u=n(333),p=n(97),f=n(314),h=n(396),d=n(477),v=n(72),g=n(469);function y(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,i)}return n}var P=function(t){function e(t){return Object(i.a)(this,e),Object(r.a)(this,Object(s.a)(e).call(this,function(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?y(n,!0).forEach((function(e){Object(v.a)(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):y(n).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}({},t,{attributes:{positions:{size:3,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})))}return Object(c.a)(e,t),Object(o.a)(e,[{key:"getGeometryFromBuffer",value:function(t){return this.normalize?Object(a.a)(Object(s.a)(e.prototype),"getGeometryFromBuffer",this).call(this,t):function(){return null}}},{key:"get",value:function(t){return this.attributes[t]}},{key:"getGeometrySize",value:function(t){if(!this.normalize){var e=t.length/this.positionSize;return this.opts.loop?e+2:e}var n=this.getPathLength(t);return n<2?0:this.isClosed(t)?n<3?0:n+2:n}},{key:"updateGeometryAttributes",value:function(t,e){0!==e.geometrySize&&(this._updateSegmentTypes(t,e),this._updatePositions(t,e))}},{key:"_updateSegmentTypes",value:function(t,e){var n=this.attributes.segmentTypes,i=this.isClosed(t),o=e.vertexStart,r=e.geometrySize;n.fill(0,o,o+r),i?(n[o]=4,n[o+r-2]=4):(n[o]+=1,n[o+r-2]+=2),n[o+r-1]=4}},{key:"_updatePositions",value:function(t,e){var n=this.attributes.positions;if(n)for(var i=e.vertexStart,o=e.geometrySize,r=i,s=0;s<o;r++,s++){var a=this.getPointOnPath(t,s);n[3*r]=a[0],n[3*r+1]=a[1],n[3*r+2]=a[2]||0}}},{key:"getPathLength",value:function(t){return Number.isFinite(t[0])?t.length/this.positionSize:t.length}},{key:"getPointOnPath",value:function(t,e){if(Number.isFinite(t[0])){var n=this.positionSize;return e*n>=t.length&&(e+=1-t.length/n),[t[e*n],t[e*n+1],3===n?t[e*n+2]:0]}return e>=t.length&&(e+=1-t.length),t[e]}},{key:"isClosed",value:function(t){if(!this.normalize)return this.opts.loop;var e=this.getPathLength(t),n=this.getPointOnPath(t,0),i=this.getPointOnPath(t,e-1);return n[0]===i[0]&&n[1]===i[1]&&n[2]===i[2]}}]),e}(g.a);n.d(e,"a",(function(){return S}));var m=[0,0,0,255],b={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},rounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:function(t){return t.path}},getColor:{type:"accessor",value:m},getWidth:{type:"accessor",value:1}},x={enter:function(t,e){return e.length?e.subarray(e.length-t.length):t}},S=function(t){function e(){return Object(i.a)(this,e),Object(r.a)(this,Object(s.a)(e).apply(this,arguments))}return Object(c.a)(e,t),Object(o.a)(e,[{key:"getShaders",value:function(){return Object(a.a)(Object(s.a)(e.prototype),"getShaders",this).call(this,{vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  float relativePosition, bool isEnd, bool isJoint,\n  vec2 width, vec2 widthPixels\n) {\n  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;\n  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  lenA = lenA > EPSILON ? lenA : 0.0;\n  lenB = lenB > EPSILON ? lenB : 0.0;\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  float cornerPosition = isJoint ?\n    0.0 :\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\n  cornerPosition *=\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);\n  if (cornerPosition < 0.0) {\n    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));\n  }\n\n  vMiterLength = cornerPosition >= 0.0 ?\n    mix(offsetScale, 0.0, cornerPosition) :\n    offsetScale * cornerPosition;\n  vMiterLength -= sinHalfA * jointType;\n\n  float offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\n  if (isStartCap) {\n    offsetVec = mix(dirB, perpB, cornerPosition);\n  }\n  if (isEndCap) {\n    offsetVec = mix(dirA, perpA, cornerPosition);\n  }\n  if (isCap) {\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\n    vMiterLength = 1.0 - cornerPosition;\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\n  }\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vPathLength = L;\n  vec2 offsetFromStartOfPath = vCornerOffset;\n  if (isEnd) {\n    offsetFromStartOfPath += deltaA;\n  }\n  vec2 dir = isEnd ? dirA : dirB;\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(vCornerOffset * widthPixels * isValid, 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  return currPoint + vec3(offset.xy / widthPixels * width, 0.0);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float relativePosition = positions.y;\n  bool isEnd = positions.x > EPSILON;\n  bool isJoint = positions.z > EPSILON;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n\n  vec2 width = billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels);\n\n  return lineJoin(\n    prevPoint, currPoint, nextPoint,\n    relativePosition, isEnd, isJoint,\n    width, widthPixels\n  );\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.worldPosition = instanceStartPositions;\n  geometry.worldPositionAlt = instanceEndPositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\n    discard;\n  }\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\n    discard;\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[l.a,u.a]})}},{key:"initializeState",value:function(){var t=this;this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:x,accessor:"getPath",update:this.calculatePositions,noAlloc:!0,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:x,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:x,defaultValue:m},instancePickingColors:{size:3,type:5121,accessor:function(e,n){var i=n.index,o=n.target;return t.encodePickingColor(i,o)}}}),this.setState({pathTesselator:new P({fp64:this.use64bitPositions()})}),this.props.getDashArray&&!this.props.extensions.length&&p.a.removed("getDashArray","PathStyleExtension")()}},{key:"updateState",value:function(t){var n=t.oldProps,i=t.props,o=t.changeFlags;Object(a.a)(Object(s.a)(e.prototype),"updateState",this).call(this,{props:i,oldProps:n,changeFlags:o});var r=this.getAttributeManager();if(o.dataChanged||o.updateTriggersChanged&&(o.updateTriggersChanged.all||o.updateTriggersChanged.getPath)){var c=this.state.pathTesselator,l=i.data.attributes||{};c.updateGeometry({data:i.data,geometryBuffer:l.getPath,buffers:l,normalize:!i._pathType,loop:"loop"===i._pathType,getGeometry:i.getPath,positionFormat:i.positionFormat,dataChanged:o.dataChanged}),this.setState({numInstances:c.instanceCount,startIndices:c.vertexStarts}),o.dataChanged||r.invalidateAll()}if(o.extensionsChanged){var u=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(u)}),r.invalidateAll()}}},{key:"draw",value:function(t){var e=t.uniforms,n=this.context.viewport,i=this.props,o=i.rounded,r=i.billboard,s=i.miterLimit,a=i.widthUnits,c=i.widthScale,l=i.widthMinPixels,u=i.widthMaxPixels,p="pixels"===a?n.metersPerPixel:1;this.state.model.setUniforms(Object.assign({},e,{jointType:Number(o),billboard:r,widthScale:c*p,miterLimit:s,widthMinPixels:l,widthMaxPixels:u})).draw()}},{key:"_getModel",value:function(t){return new h.a(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new d.a({drawMode:4,attributes:{indices:new Uint16Array([0,2,1,1,2,4,1,4,3,3,4,5]),positions:new Float32Array([0,0,1,0,-1,0,0,1,0,1,-1,0,1,1,0,1,0,1])}}),isInstanced:!0}))}},{key:"calculatePositions",value:function(t){var e=this.state.pathTesselator;t.startIndices=e.vertexStarts,t.value=e.get("positions")}},{key:"calculateSegmentTypes",value:function(t){var e=this.state.pathTesselator;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}}]),e}(f.a);S.layerName="PathLayer",S.defaultProps=b},469:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var i=n(57),o=n(58),r=n(208),s=n(207),a=n(105),c=n(145),l=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object(i.a)(this,t);var n=e.attributes,o=void 0===n?{}:n;this.typedArrayManager=s.a,this.indexStarts=null,this.vertexStarts=null,this.vertexCount=0,this.instanceCount=0,this.attributes={},this._attributeDefs=o,this.opts=e,this.updateGeometry(e),Object.seal(this)}return Object(o.a)(t,[{key:"updateGeometry",value:function(t){Object.assign(this.opts,t);var e=this.opts,n=e.data,i=e.buffers,o=void 0===i?{}:i,r=e.getGeometry,s=e.geometryBuffer,c=e.positionFormat,l=e.dataChanged,u=e.normalize,p=void 0===u||u;if(this.data=n,this.getGeometry=r,this.positionSize=s&&s.size||("XY"===c?2:3),this.buffers=o,this.normalize=p,s&&(Object(a.a)(n.startIndices,"binary data missing startIndices"),this.getGeometry=this.getGeometryFromBuffer(s),p||(o.positions=s)),this.geometryBuffer=o.positions,Array.isArray(l)){var f=!0,h=!1,d=void 0;try{for(var v,g=l[Symbol.iterator]();!(f=(v=g.next()).done);f=!0){var y=v.value;this._rebuildGeometry(y)}}catch(t){h=!0,d=t}finally{try{f||null==g.return||g.return()}finally{if(h)throw d}}}else this._rebuildGeometry()}},{key:"updatePartialGeometry",value:function(t){var e=t.startRow,n=t.endRow;this._rebuildGeometry({startRow:e,endRow:n})}},{key:"updateGeometryAttributes",value:function(t,e,n){throw new Error("Not implemented")}},{key:"getGeometrySize",value:function(t){throw new Error("Not implemented")}},{key:"getGeometryFromBuffer",value:function(t){var e=t.value||t;return Object(a.a)(ArrayBuffer.isView(e),"cannot read geometries"),Object(r.b)(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices})}},{key:"_allocate",value:function(t,e){var n=this.attributes,i=this.buffers,o=this._attributeDefs,r=this.typedArrayManager;for(var s in o)if(s in i)r.release(n[s]),n[s]=null;else{var a=o[s];a.copy=e,n[s]=r.allocate(n[s],t,a)}}},{key:"_forEachGeometry",value:function(t,e,n){var i=this.data,o=this.getGeometry,s=Object(r.a)(i,e,n),a=s.iterable,c=s.objectInfo,l=!0,u=!1,p=void 0;try{for(var f,h=a[Symbol.iterator]();!(l=(f=h.next()).done);l=!0){var d=f.value;c.index++,t(o(d,c),c.index)}}catch(t){u=!0,p=t}finally{try{l||null==h.return||h.return()}finally{if(u)throw p}}}},{key:"_rebuildGeometry",value:function(t){var e=this;if(this.data&&this.getGeometry){var n=this.indexStarts,i=this.vertexStarts,o=this.instanceCount,r=this.data,s=this.geometryBuffer,a=t||{},l=a.startRow,u=void 0===l?0:l,p=a.endRow,f=void 0===p?1/0:p;if(t||(n=[0],i=[0]),this.normalize||!s)this._forEachGeometry((function(t,n){i[n+1]=i[n]+e.getGeometrySize(t)}),u,f),o=i[i.length-1];else if(s.buffer instanceof c.a){var h=s.stride||4*this.positionSize;i=r.startIndices,o=i[r.length]||s.buffer.byteLength/h}else{var d=s.value||s,v=s.stride/d.BYTES_PER_ELEMENT||this.positionSize;i=r.startIndices,o=i[r.length]||d.length/v}this._allocate(o,Boolean(t)),this.indexStarts=n,this.vertexStarts=i,this.instanceCount=o;var g={};this._forEachGeometry((function(t,r){g.vertexStart=i[r],g.indexStart=n[r];var s=r<i.length-1?i[r+1]:o;g.geometrySize=s-i[r],g.geometryIndex=r,e.updateGeometryAttributes(t,g)}),u,f),this.vertexCount=n[n.length-1]}}}]),t}()},613:function(t,e,n){"use strict";var i=n(57),o=n(58),r=n(84),s=n(641),a=n(483);function c(t){var e=t.map,n=t.gl,i=t.deck;if(e.__deck)return e.__deck;var o=i&&i.props._customRender,a={useDevicePixels:!0,_customRender:function(){e.triggerRepaint(),o&&o()},parameters:{depthMask:!0,depthTest:!0,blendFunc:[770,771,1,771],blendEquation:32774},userData:{isExternal:!1,mapboxLayers:new Set}};return i?(i.setProps(a),i.props.userData.isExternal=!0):(Object.assign(a,{gl:n,width:!1,height:!1,viewState:l(e)}),i=new s.a(a),e.on("move",(function(){return function(t,e){t.setProps({viewState:l(e)}),t.needsRedraw({clearRedrawFlags:!0})}(i,e)})),e.on("remove",(function(){i.finalize(),e.__deck=null}))),i.props.userData.mapboxVersion=function(t){var e=0,n=0;if(t.version){var i=t.version.split(".").slice(0,2).map(Number),o=Object(r.a)(i,2);e=o[0],n=o[1]}return{major:e,minor:n}}(e),e.__deck=i,e.on("render",(function(){return function(t,e){var n=t.props.userData,i=n.mapboxLayers;if(n.isExternal){var o=Array.from(i,(function(t){return t.id})),r=p(t,(function(t){var e=!0,n=!1,i=void 0;try{for(var r,s=o[Symbol.iterator]();!(e=(r=s.next()).done);e=!0){if(f(r.value,t))return!1}}catch(t){n=!0,i=t}finally{try{e||null==s.return||s.return()}finally{if(n)throw i}}return!0}));r.length>0&&t._drawLayers("mapbox-repaint",{viewports:[u(t,e,!1)],layers:r,clearCanvas:!1})}t.props.userData.currentViewport=null}(i,e)})),i}function l(t){var e=t.getCenter();return{longitude:e.lng,latitude:e.lat,zoom:t.getZoom(),bearing:t.getBearing(),pitch:t.getPitch()}}function u(t,e){var n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=t.props.userData.mapboxVersion;return new a.a(Object.assign({x:0,y:0,width:t.width,height:t.height},l(e),n?{nearZMultiplier:1===i.major&&i.minor>=3||i.major>=2?.02:1/(t.height||1)}:{nearZMultiplier:.1}))}function p(t,e){return t.layerManager.getLayers().filter(e)}function f(t,e){for(var n=e;n;){if(n.id===t)return!0;n=n.parent}return!1}function h(t){if(!t.props.userData.isExternal){var e=[];t.props.userData.mapboxLayers.forEach((function(t){var n=new(0,t.props.type)(t.props);e.push(n)})),t.setProps({layers:e})}}n.d(e,"a",(function(){return d}));var d=function(){function t(e){if(Object(i.a)(this,t),!e.id)throw new Error("Layer must have an unique id");this.id=e.id,this.type="custom",this.renderingMode=e.renderingMode||"3d",this.map=null,this.deck=null,this.props=e}return Object(o.a)(t,[{key:"onAdd",value:function(t,e){var n,i;this.map=t,this.deck=c({map:t,gl:e,deck:this.props.deck}),n=this.deck,i=this,n.props.userData.mapboxLayers.add(i),h(n)}},{key:"onRemove",value:function(){var t,e;t=this.deck,e=this,t.props.userData.mapboxLayers.delete(e),h(t)}},{key:"setProps",value:function(t){Object.assign(this.props,t,{id:this.id}),this.deck&&h(this.deck)}},{key:"render",value:function(t,e){var n,i,o,r;n=this.deck,i=this.map,o=this,(r=n.props.userData.currentViewport)||(r=u(n,i,!0),n.props.userData.currentViewport=r),n._drawLayers("mapbox-repaint",{viewports:[r],layers:p(n,(function(t){return f(o.id,t)})),clearCanvas:!1})}}]),t}()}}]);